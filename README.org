#+TITLE: Cubes!

* Progress
- [X] 2x2
- [X] 3x3
- [ ] Displaying step-by-step from svgs

* Genreal
** Usage 
The program has three options: =gen=, =solve=, =rand=.

To input a specific 2x2 (or 3x3) into the program, you must =cargo run --release --bin tubaitu -- gen= (=cargo run --release --bin tubaitu -- gen=). Note the space before the =--=!

You should now have a file called =tubaitu_input_file= (or =tribaitri_input_file=). Input your state into it, replacing all =X= with any of =W=, =Y=, =R=, =O=, =B=, =G= as appropriate.

Now, to get a solve, run =cargo run --release --bin tubaitu -- solve= (or =cargo run --release --bin tribaitri -- solve=)

To use a random scramble instead, use =cargo run --release --bin tubaitu -- rand= (=cargo run --release --bin tribaitri=)

** Solving
Solving is done by brute force: we generate a graph where the vertexes are a unique (modulo symmetry) cube state and each edge is the corresponding move. We may then traverse the graph via two BFS (starting from the solved state and the unsolved state) until they both encounter the same state. Having reached this point, getting the path is trivial.

** Adding cubes
Inside the =shared= package, the =Solvable= trait is defined. When implementing it on a type, only =T::make_move()= and =moves_of_adjacency()= are missing members (for changing state and finding all adjacent states, respectively). The function =T::solve()= is autogenerated from those via generics, though of course it may be replaced by implementing it normally. As convenience, the methods =T::scramble= and =T::random_scramble()= also contain default implementations.

** Shared representation
*** Pieces
Pieces are represented with an enum with variants like =WR=, =WB=, etc. These correspond to a 1x1 cube where the top face has the first color and the front face has the second color. This saves on memory and, more importantly, computation time.

**** Piece (6 colors)
#+BEGIN_SRC txt
         +--------+   
        /        /|     
       /    2   / |  < -- 4  (the back)  
      +--------+  |     
      |        | 0|     
      |        |  +     
3 ->  |   1    | /      
      |        |/  ^      
      +--------+   |-- 5     
#+END_SRC

As in:
- 0: Right
- 1: Front
- 2: Top
- 3: Left
- 4: Back
- 5: Down

This is stored internally as a C-style (unit) enum, of course.


* Tubaitu
** Internal representation
Each 2x2 cube is represented by eight pieces, each of which has six color (three of them are visible at any one time). This makes rotations easier to compute.

These eight pieces are stored in an array of eight `Piece`s. The position of each element in the array has been (arbitrarily) decided to be this one, stored in a C-style (unit) enum:

Note that indicies here were named independently of the colors.

| Position           | Index |
|--------------------+-------|
| Top right front    |     0 |
| Top right back     |     1 |
| Top left back      |     2 |
| Top left front     |     3 |
| Bottom right front |     4 |
| Bottom right back  |     5 |
| Bottom left back   |     6 |
| Bottom left front  |     7 |


* Tribaitri
** Internal representation
Each 3x3 cube is represented by 20 pieces (8 edges + 16 corners, the centers are implicit), each of which has six color (three of them are visible at any one time). This, again, makes rotations easier to compute.

These twenty pieces are stored in an twenty of eight `Piece`s. The position of each element in the array has been (arbitrarily) decided to be this one, stored in a C-style (unit) enum.

Note that indicies here were named in relation to their corresponding colors (since they uniquely represent each piece). This was done to maintain sanity.

| Name (corners) | Index |
|----------------+-------|
| WRB            |     0 |
| WBO            |     1 |
| WOG            |     2 |
| WGR            |     3 |
| YBR            |     4 |
| YBO            |     5 |
| YOG            |     6 |
| YRG            |     7 |

| Name (edges) | Index |
| WR           |     8 |
| WB           |     9 |
| WO           |    10 |
| WG           |    11 |
| YR           |    12 |
| YB           |    13 |
| YO           |    14 |
| YG           |    15 |
| OB           |    16 |
| BR           |    17 |
| RG           |    18 |
| GO           |    19 |

The indicies of the 20-element array are stored as TWO C-style (unit) enum: =ThreeByCorner= (for the 0 corners) and =ThreeByEdge= for the 8 edges. Their discriminants are non-overlapping and used as indicies of the 20-element array. To execute rotations, the pieces are cycled edge-wise then corner-wise (a cycle of four, then another), re-using the method for the 2x2.
